<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SMU Mustangs Student Engagement Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="info-container">
    <div class="title">SMU Mustangs Engagement</div>
    <div class="subtitle">Class of 2026: Visualizing campus involvement through Mustang spirit</div>
    <div class="info">Hover over any mustang to explore student engagement data for different group sizes.</div>
  </div>

  <script>
    let dataArt;
    let mustangSvg;

    function preload() {
      // Load the SVG file - make sure this file exists in your project folder
      mustangSvg = loadImage('mustang.svg');
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(RGB); // Switch to RGB for SMU brand colors
      textFont('Arial');
      frameRate(30);
      
      // Initialize the visualization
      dataArt = new MustangsEngagementArt();
    }

    function draw() {
      background(53, 76, 161); // SMU Blue background
      dataArt.update();
      dataArt.display();
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      dataArt.resize();
    }

    function mouseMoved() {
      dataArt.checkHover(mouseX, mouseY);
    }

    class MustangsEngagementArt {
      constructor() {
        this.studentData = [
          { groupRange: "0-5", avgTotal: 3.8, avgActive: 0.1, activeRatio: 1.7 },
          { groupRange: "6-9", avgTotal: 7.9, avgActive: 0.9, activeRatio: 11.0 },
          { groupRange: "10-13", avgTotal: 11.5, avgActive: 2.3, activeRatio: 20.3 },
          { groupRange: "14-17", avgTotal: 15.5, avgActive: 3.8, activeRatio: 24.5 },
          { groupRange: "18-21", avgTotal: 19.5, avgActive: 5.0, activeRatio: 25.7 },
          { groupRange: "22-25", avgTotal: 23.6, avgActive: 6.2, activeRatio: 26.3 },
          { groupRange: "26-29", avgTotal: 27.4, avgActive: 7.0, activeRatio: 25.5 },
          { groupRange: "30-33", avgTotal: 31.4, avgActive: 8.1, activeRatio: 25.6 },
          { groupRange: "34-37", avgTotal: 35.5, avgActive: 9.5, activeRatio: 26.9 },
          { groupRange: "38-41", avgTotal: 39.4, avgActive: 9.8, activeRatio: 24.9 },
          { groupRange: "42-45", avgTotal: 43.6, avgActive: 15.0, activeRatio: 34.3 },
          { groupRange: "46-49", avgTotal: 47.7, avgActive: 10.9, activeRatio: 22.8 },
          { groupRange: "50-59", avgTotal: 54.3, avgActive: 12.8, activeRatio: 23.6 },
          { groupRange: "60-69", avgTotal: 64.5, avgActive: 11.1, activeRatio: 17.2 },
          { groupRange: "70+", avgTotal: 79.0, avgActive: 7.0, activeRatio: 8.4 }
        ];
        
        // SMU brand colors in RGB format
        this.smuBlue = [53, 76, 161];
        this.smuRed = [204, 0, 53]; 
        this.smuYellow = [249, 200, 14];
        this.smuTeal = [89, 195, 195];
        this.white = [255, 255, 255];
        
        // Color palette for mustangs based on activation ratio
        this.colorPalette = [
          this.white,      // Lowest activation (0%)
          this.smuTeal,    // Low activation
          this.smuYellow,  // Medium activation
          this.smuRed      // Highest activation (35%+)
        ];
        
        this.mustangs = [];
        this.activeGroups = [];
        this.inactiveGroups = [];
        this.centerX = windowWidth / 2;
        this.centerY = windowHeight / 2;
        this.maxRadius = min(windowWidth, windowHeight) * 0.4;
        this.hoverMustang = null;
        this.time = 0;
        
        // Animation settings - increased speed from previous version
        this.animationSpeed = 0.8; // Faster animation
        
        this.initializeVisualization();
      }
      
      // Get color by interpolating through the palette based on activation ratio
      getColorFromPalette(ratio) {
        // Map the ratio to a position in our color palette
        const maxRatio = 35; // Maximum activation ratio in our data
        const normalizedRatio = constrain(ratio / maxRatio, 0, 1);
        
        // Calculate which segment of the palette we're in
        const segments = this.colorPalette.length - 1;
        const segment = normalizedRatio * segments;
        const index = floor(segment);
        const t = segment - index; // fractional part for interpolation
        
        if (index >= segments) {
          return this.colorPalette[segments];
        }
        
        // Linear interpolation between the two closest colors
        const colorA = this.colorPalette[index];
        const colorB = this.colorPalette[index + 1];
        
        return [
          lerp(colorA[0], colorB[0], t),
          lerp(colorA[1], colorB[1], t),
          lerp(colorA[2], colorB[2], t)
        ];
      }
      
      initializeVisualization() {
        // Create a grid layout for mustangs
        const rows = 3;
        const cols = 5;
        const totalMustangs = this.studentData.length;
        
        const gridSpacingX = windowWidth * 0.7 / (cols - 1);
        const gridSpacingY = windowHeight * 0.6 / (rows - 1);
        const startX = this.centerX - (gridSpacingX * (cols - 1)) / 2;
        const startY = this.centerY - (gridSpacingY * (rows - 1)) / 2;
        
        // Create mustangs for each student group range
        for (let i = 0; i < totalMustangs; i++) {
          // Calculate grid position
          const row = Math.floor(i / cols);
          const col = i % cols;
          
          const x = startX + col * gridSpacingX;
          const y = startY + row * gridSpacingY;
          
          // Determine mustang size based on total group count
          const size = map(sqrt(this.studentData[i].avgTotal), 0, sqrt(80), 50, 130); // Increased base size
          
          // Get color based on activation ratio
          const colorRgb = this.getColorFromPalette(this.studentData[i].activeRatio);
          
          const mustang = {
            x: x,
            y: y,
            targetX: x,
            targetY: y,
            size: size,
            data: this.studentData[i],
            colorRgb: colorRgb,
            angle: 0,
            galloping: 0,
            gallopSpeed: random(0.04, 0.06) * this.animationSpeed, // Faster animation
            hovering: false,
            row: row,
            col: col,
            // All mustangs facing same direction
            flipX: false
          };
          
          this.mustangs.push(mustang);
          
          // Create active student groups around this mustang
          const activeCount = ceil(mustang.data.avgActive);
          for (let j = 0; j < activeCount; j++) {
            const angle = random(TWO_PI);
            const radius = mustang.size * 1.5 * random(0.8, 1.2);
            const activeGroup = {
              x: mustang.x + cos(angle) * radius,
              y: mustang.y + sin(angle) * radius,
              size: 9, // Slightly larger dots
              parentMustang: mustang,
              colorRgb: this.smuRed.slice(), // Clone the color array
              opacity: j < mustang.data.avgActive ? 1 : 0.3, // Partial opacity for fractional counts
              angle: angle,
              distance: radius,
              speed: random(0.015, 0.025)
            };
            this.activeGroups.push(activeGroup);
          }
          
          // Create inactive student groups (limited for visual clarity)
          const inactiveCount = ceil(mustang.data.avgTotal - mustang.data.avgActive);
          const inactiveDisplayCount = min(inactiveCount, 40);
          
          for (let j = 0; j < inactiveDisplayCount; j++) {
            const angle = random(TWO_PI);
            const radius = mustang.size * 1.2 * random(0.8, 1.2);
            const inactiveGroup = {
              x: mustang.x + cos(angle) * radius,
              y: mustang.y + sin(angle) * radius,
              size: 6, // Slightly larger dots
              parentMustang: mustang,
              colorRgb: this.smuTeal.slice(), // Clone the color array
              opacity: j < inactiveCount ? 0.6 : 0.2,
              angle: angle,
              distance: radius,
              speed: random(0.008, 0.012)
            };
            this.inactiveGroups.push(inactiveGroup);
          }
        }
      }
      
      resize() {
        this.centerX = windowWidth / 2;
        this.centerY = windowHeight / 2;
        
        // Recalculate grid layout
        const rows = 3;
        const cols = 5;
        
        const gridSpacingX = windowWidth * 0.7 / (cols - 1);
        const gridSpacingY = windowHeight * 0.6 / (rows - 1);
        const startX = this.centerX - (gridSpacingX * (cols - 1)) / 2;
        const startY = this.centerY - (gridSpacingY * (rows - 1)) / 2;
        
        // Reposition mustangs
        for (let i = 0; i < this.mustangs.length; i++) {
          const mustang = this.mustangs[i];
          const row = mustang.row;
          const col = mustang.col;
          
          mustang.targetX = startX + col * gridSpacingX;
          mustang.targetY = startY + row * gridSpacingY;
        }
      }
      
      update() {
        this.time += 0.01;
        
        // Update mustangs
        for (let mustang of this.mustangs) {
          mustang.x = lerp(mustang.x, mustang.targetX, 0.1);
          mustang.y = lerp(mustang.y, mustang.targetY, 0.1);
          
          // Galloping animation - more like a gentle rocking motion
          // Using a smoother curve with less extreme values
          mustang.galloping = sin(this.time * mustang.gallopSpeed * 5) * 0.6;
          
          // If hovering, make the mustang slightly more animated but still smooth
          if (mustang.hovering) {
            mustang.gallopSpeed = 0.08 * this.animationSpeed;
          } else {
            mustang.gallopSpeed = random(0.04, 0.06) * this.animationSpeed;
          }
        }
        
        // Update active groups
        for (let group of this.activeGroups) {
          const parent = group.parentMustang;
          
          // Follow parent mustang with a slight delay
          group.angle += group.speed;
          group.x = parent.x + cos(group.angle) * group.distance;
          group.y = parent.y + sin(group.angle) * group.distance;
        }
        
        // Update inactive groups
        for (let group of this.inactiveGroups) {
          const parent = group.parentMustang;
          
          // Slow movement around parent mustang
          group.angle += group.speed * 0.5;
          group.x = parent.x + cos(group.angle) * group.distance;
          group.y = parent.y + sin(group.angle) * group.distance;
        }
      }
      
      display() {
        // Draw SMU logo in background
        this.drawBackgroundElements();
        
        // Draw inactive groups
        for (let group of this.inactiveGroups) {
          noStroke();
          fill(group.colorRgb[0], group.colorRgb[1], group.colorRgb[2], 255 * group.opacity);
          ellipse(group.x, group.y, group.size);
        }
        
        // Draw active groups
        for (let group of this.activeGroups) {
          noStroke();
          fill(group.colorRgb[0], group.colorRgb[1], group.colorRgb[2], 255 * group.opacity);
          ellipse(group.x, group.y, group.size);
          
          // Add glow to active groups
          fill(group.colorRgb[0], group.colorRgb[1], group.colorRgb[2], 255 * group.opacity * 0.3);
          ellipse(group.x, group.y, group.size * 1.5);
        }
        
        // Draw mustangs
        for (let mustang of this.mustangs) {
          this.drawMustangSvg(mustang);
        }
        
        // Draw hover information
        if (this.hoverMustang) {
          this.drawMustangInfo(this.hoverMustang);
        }
      }
      
      drawBackgroundElements() {
        // Draw a large SMU in the background
        noStroke();
        fill(255, 255, 255, 15); // Subtle white text
        textAlign(CENTER, CENTER);
        textStyle(BOLD);
        textSize(width * 0.3);
        text("SMU", this.centerX, this.centerY);
      }
      
      drawMustangSvg(mustang) {
        push();
        translate(mustang.x, mustang.y);
        
        // Apply gentler rocking animation
        // This is more subtle and feels like a rocking horse
        const gallopAmount = mustang.galloping;
        rotate(gallopAmount * 0.05); // Reduced rotation for subtle effect
        
        // Flip horizontally if needed
        if (mustang.flipX) {
          scale(-1, 1);
        }
        
        // Apply the color tint using RGB colors
        tint(mustang.colorRgb[0], mustang.colorRgb[1], mustang.colorRgb[2]);
        
        // Calculate aspect ratio adjustment, assuming svg has width of 612
        const targetWidth = mustang.size;
        const targetHeight = targetWidth * (mustangSvg.height / mustangSvg.width);
        
        // Draw the SVG image
        imageMode(CENTER);
        image(mustangSvg, 0, 0, targetWidth, targetHeight);
        
        // Remove tint
        noTint();
        
        pop();
        
        // Add text for group count range directly below without box
        push();
        textAlign(CENTER, CENTER);
        textStyle(BOLD);
        
        // Draw white outline text for better visibility against any background
        let groupTextY = mustang.y + mustang.size * 0.6;
        
        // Draw text outline/shadow for better readability
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            if (i !== 0 || j !== 0) { // Skip the center position
              fill(0, 0, 0, 150);
              textSize(mustang.size * 0.20); // Increased text size
              text(mustang.data.groupRange, mustang.x + i, groupTextY + j);
            }
          }
        }
        
        // Main text - group range
        fill(255, 255, 255, 255);
        textSize(mustang.size * 0.20); // Increased text size
        text(mustang.data.groupRange, mustang.x, groupTextY);
        
        // Activation percentage with similar outline technique
        let percentTextY = groupTextY + mustang.size * 0.22;
        textSize(mustang.size * 0.16); // Increased text size
        
        // Outline/shadow for percentage
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            if (i !== 0 || j !== 0) {
              fill(0, 0, 0, 150);
              text(`${mustang.data.activeRatio.toFixed(1)}%`, mustang.x + i, percentTextY + j);
            }
          }
        }
        
        // Main text - percentage
        fill(this.smuYellow[0], this.smuYellow[1], this.smuYellow[2], 255);
        text(`${mustang.data.activeRatio.toFixed(1)}%`, mustang.x, percentTextY);
        
        pop();
        
        // If hovering, add subtle highlight/glow
        if (mustang.hovering) {
          noFill();
          stroke(255, 255, 255, 180);
          strokeWeight(2);
          ellipse(mustang.x, mustang.y, mustang.size * 1.5);
        }
      }
      
      drawMustangInfo(mustang) {
        const data = mustang.data;
        const infoX = mustang.x + mustang.size;
        const infoY = mustang.y - mustang.size * 0.5;
        
        // Draw info panel background with increased opacity
        fill(33, 46, 121, 245); // Darker SMU Blue background with 96% opacity
        stroke(204, 0, 53);
        strokeWeight(2);
        rectMode(CORNER);
        rect(infoX, infoY, 240, 140, 10); // Larger panel for bigger text
        
        // Draw info text - increased text size
        noStroke();
        textAlign(LEFT, TOP);
        fill(255);
        textSize(18); // Increased from 16
        text(`Group Range: ${data.groupRange}`, infoX + 12, infoY + 12);
        
        textSize(16); // Increased from 14
        fill(240);
        text(`Total Groups: ${data.avgTotal.toFixed(1)}`, infoX + 12, infoY + 42);
        
        // Use SMU red for active groups
        fill(204, 0, 53);
        text(`Active Groups: ${data.avgActive.toFixed(1)}`, infoX + 12, infoY + 72);
        
        // Use SMU teal for inactive groups
        fill(89, 195, 195);
        text(`Inactive Groups: ${(data.avgTotal - data.avgActive).toFixed(1)}`, infoX + 12, infoY + 102);
      }
      
      checkHover(x, y) {
        let hoveredMustang = null;
        
        // Reset hover state
        for (let mustang of this.mustangs) {
          mustang.hovering = false;
        }
        
        // Check if mouse is over any mustang
        for (let mustang of this.mustangs) {
          const d = dist(x, y, mustang.x, mustang.y);
          if (d < mustang.size * 0.6) {
            hoveredMustang = mustang;
            mustang.hovering = true;
            break;
          }
        }
        
        this.hoverMustang = hoveredMustang;
      }
    }
  </script>
</body>
</html>