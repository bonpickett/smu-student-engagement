<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SMU Mustangs Student Engagement Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="title">SMU Mustangs Engagement Constellation</div>
  <div class="subtitle">Class of 2026: Visualizing how Mustang students connect with campus groups</div>
  <div class="info">Hover over stars to explore the data patterns. Each star system represents a different range of student group memberships.</div>

  <script>
    function setup() {
      createCanvas(windowWidth, windowHeight);
      colorMode(HSB, 360, 100, 100, 1);
      textFont('Arial');
      frameRate(30);
      
      // Initialize the visualization
      dataArt = new MustangsEngagementArt();
    }

    function draw() {
      background(230, 15, 5);
      dataArt.update();
      dataArt.display();
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
      dataArt.resize();
    }

    function mouseMoved() {
      dataArt.checkHover(mouseX, mouseY);
    }

    class MustangsEngagementArt {
      constructor() {
        this.studentData = [
          { groupRange: "0-5", avgTotal: 3.8, avgActive: 0.1, activeRatio: 1.7 },
          { groupRange: "6-9", avgTotal: 7.9, avgActive: 0.9, activeRatio: 11.0 },
          { groupRange: "10-13", avgTotal: 11.5, avgActive: 2.3, activeRatio: 20.3 },
          { groupRange: "14-17", avgTotal: 15.5, avgActive: 3.8, activeRatio: 24.5 },
          { groupRange: "18-21", avgTotal: 19.5, avgActive: 5.0, activeRatio: 25.7 },
          { groupRange: "22-25", avgTotal: 23.6, avgActive: 6.2, activeRatio: 26.3 },
          { groupRange: "26-29", avgTotal: 27.4, avgActive: 7.0, activeRatio: 25.5 },
          { groupRange: "30-33", avgTotal: 31.4, avgActive: 8.1, activeRatio: 25.6 },
          { groupRange: "34-37", avgTotal: 35.5, avgActive: 9.5, activeRatio: 26.9 },
          { groupRange: "38-41", avgTotal: 39.4, avgActive: 9.8, activeRatio: 24.9 },
          { groupRange: "42-45", avgTotal: 43.6, avgActive: 15.0, activeRatio: 34.3 },
          { groupRange: "46-49", avgTotal: 47.7, avgActive: 10.9, activeRatio: 22.8 },
          { groupRange: "50-59", avgTotal: 54.3, avgActive: 12.8, activeRatio: 23.6 },
          { groupRange: "60-69", avgTotal: 64.5, avgActive: 11.1, activeRatio: 17.2 },
          { groupRange: "70+", avgTotal: 79.0, avgActive: 7.0, activeRatio: 8.4 }
        ];
        
        // SMU colors
        this.smuRed = [0, 80, 90]; // HSB equivalent of SMU red
        this.smuBlue = [220, 80, 90]; // HSB equivalent of SMU blue
        
        this.nodes = [];
        this.connections = [];
        this.activeNodes = [];
        this.inactiveNodes = [];
        this.centerX = windowWidth / 2;
        this.centerY = windowHeight / 2;
        this.maxRadius = min(windowWidth, windowHeight) * 0.4;
        this.hoverNode = null;
        this.time = 0;
        this.mustangElements = [];
        
        this.initializeVisualization();
        this.createMustangElements();
      }
      
      createMustangElements() {
        // Create decorative elements representing mustang silhouettes
        const numElements = 7;
        const angleStep = TWO_PI / numElements;
        
        for (let i = 0; i < numElements; i++) {
          const angle = angleStep * i;
          const radius = this.maxRadius * 1.4;
          
          this.mustangElements.push({
            x: this.centerX + cos(angle) * radius,
            y: this.centerY + sin(angle) * radius,
            size: random(20, 40),
            angle: angle,
            speed: random(0.0005, 0.001),
            oscillationSpeed: random(0.01, 0.02),
            oscillationAmount: random(5, 15)
          });
        }
      }
      
      initializeVisualization() {
        // Create main nodes (student group ranges)
        for (let i = 0; i < this.studentData.length; i++) {
          const angle = map(i, 0, this.studentData.length, 0, TWO_PI);
          const radius = map(sqrt(this.studentData[i].avgTotal), 0, sqrt(80), 0, this.maxRadius);
          const x = this.centerX + cos(angle) * radius;
          const y = this.centerY + sin(angle) * radius;
          
          // Use SMU colors - high activation = red, low activation = blue
          const hue = map(this.studentData[i].activeRatio, 0, 35, this.smuBlue[0], this.smuRed[0]);
          const saturation = map(this.studentData[i].activeRatio, 0, 35, this.smuBlue[1], this.smuRed[1]);
          
          const node = {
            x: x,
            y: y,
            targetX: x,
            targetY: y,
            radius: map(log(this.studentData[i].avgTotal), 0, log(80), 15, 40),
            data: this.studentData[i],
            hue: hue,
            brightness: 85,
            saturation: saturation,
            angle: angle,
            baseRadius: radius,
            hovering: false
          };
          
          this.nodes.push(node);
        }
        
        // Create active and inactive participation nodes for each main node
        for (let node of this.nodes) {
          const activeCount = node.data.avgActive;
          const inactiveCount = node.data.avgTotal - node.data.avgActive;
          
          // Create active nodes - using SMU red
          const activeNodeCount = ceil(activeCount);
          for (let i = 0; i < activeNodeCount; i++) {
            const angle = node.angle + random(-PI/4, PI/4);
            const distance = node.radius * 1.8 * random(0.8, 1.2);
            const activeNode = {
              x: node.x + cos(angle) * distance,
              y: node.y + sin(angle) * distance,
              radius: 4,
              parentNode: node,
              active: true,
              hue: this.smuRed[0],
              saturation: this.smuRed[1],
              brightness: this.smuRed[2],
              opacity: i < activeCount ? 1 : 0.3, // Partial opacity for fractional counts
              angle: angle,
              distance: distance,
              speed: random(0.003, 0.008)
            };
            this.activeNodes.push(activeNode);
            
            // Create connection between main node and active node
            this.connections.push({
              start: node,
              end: activeNode,
              strength: 0.8
            });
          }
          
          // Create inactive nodes - using SMU blue
          const inactiveNodeCount = ceil(inactiveCount);
          const inactiveDisplayCount = min(inactiveNodeCount, 40); // Limit for visual clarity
          
          for (let i = 0; i < inactiveDisplayCount; i++) {
            const angle = node.angle + random(-PI/3, PI/3);
            const distance = node.radius * random(0.8, 1.5);
            const inactiveNode = {
              x: node.x + cos(angle) * distance,
              y: node.y + sin(angle) * distance,
              radius: 2,
              parentNode: node,
              active: false,
              hue: this.smuBlue[0],
              saturation: this.smuBlue[1],
              brightness: this.smuBlue[2],
              opacity: i < inactiveCount ? 0.6 : 0.2, // Partial opacity for fractional counts
              angle: angle,
              distance: distance,
              speed: random(0.001, 0.003)
            };
            this.inactiveNodes.push(inactiveNode);
            
            // Create connection between main node and inactive node
            this.connections.push({
              start: node,
              end: inactiveNode,
              strength: 0.3
            });
          }
        }
      }
      
      resize() {
        this.centerX = windowWidth / 2;
        this.centerY = windowHeight / 2;
        this.maxRadius = min(windowWidth, windowHeight) * 0.4;
        
        // Reposition nodes
        for (let i = 0; i < this.nodes.length; i++) {
          const node = this.nodes[i];
          const radius = map(sqrt(node.data.avgTotal), 0, sqrt(80), 0, this.maxRadius);
          node.targetX = this.centerX + cos(node.angle) * radius;
          node.targetY = this.centerY + sin(node.angle) * radius;
          node.baseRadius = radius;
        }
        
        // Reposition mustang elements
        for (let i = 0; i < this.mustangElements.length; i++) {
          const element = this.mustangElements[i];
          const radius = this.maxRadius * 1.4;
          element.x = this.centerX + cos(element.angle) * radius;
          element.y = this.centerY + sin(element.angle) * radius;
        }
      }
      
      update() {
        this.time += 0.01;
        
        // Update main nodes
        for (let node of this.nodes) {
          node.x = lerp(node.x, node.targetX, 0.1);
          node.y = lerp(node.y, node.targetY, 0.1);
          
          if (node.hovering) {
            node.targetX = this.centerX + cos(node.angle) * (node.baseRadius * 1.1);
            node.targetY = this.centerY + sin(node.angle) * (node.baseRadius * 1.1);
          } else {
            node.targetX = this.centerX + cos(node.angle) * node.baseRadius;
            node.targetY = this.centerY + sin(node.angle) * node.baseRadius;
          }
        }
        
        // Update active nodes
        for (let node of this.activeNodes) {
          const parent = node.parentNode;
          const wobble = sin(this.time * node.speed * 10) * 5;
          
          // Orbit around parent node with slight wobble
          node.angle += node.speed;
          node.x = parent.x + cos(node.angle) * (node.distance + wobble);
          node.y = parent.y + sin(node.angle) * (node.distance + wobble);
        }
        
        // Update inactive nodes
        for (let node of this.inactiveNodes) {
          const parent = node.parentNode;
          
          // Just slight movement around original position
          const drift = sin(this.time * node.speed * 5) * 3;
          node.x = parent.x + cos(node.angle) * (node.distance + drift);
          node.y = parent.y + sin(node.angle) * (node.distance + drift);
        }
        
        // Update mustang elements
        for (let element of this.mustangElements) {
          element.angle += element.speed;
          const oscillation = sin(this.time * element.oscillationSpeed) * element.oscillationAmount;
          const radius = this.maxRadius * 1.4 + oscillation;
          element.x = this.centerX + cos(element.angle) * radius;
          element.y = this.centerY + sin(element.angle) * radius;
        }
      }
      
      display() {
        // Draw background gradient
        this.drawBackgroundGradient();
        
        // Draw mustang silhouettes in the background
        this.drawMustangElements();
        
        // Draw connections
        this.drawConnections();
        
        // Draw inactive nodes
        for (let node of this.inactiveNodes) {
          noStroke();
          fill(node.hue, node.saturation, node.brightness, node.opacity * 0.8);
          ellipse(node.x, node.y, node.radius * 2);
        }
        
        // Draw active nodes
        for (let node of this.activeNodes) {
          noStroke();
          fill(node.hue, node.saturation, node.brightness, node.opacity);
          ellipse(node.x, node.y, node.radius * 2);
          
          // Add glow effect
          for (let i = 0; i < 3; i++) {
            fill(node.hue, node.saturation, node.brightness, node.opacity * (0.2 - i * 0.05));
            ellipse(node.x, node.y, node.radius * (2 + i * 1.5));
          }
        }
        
        // Draw main nodes
        for (let node of this.nodes) {
          // Draw glow for main nodes
          for (let i = 0; i < 4; i++) {
            noStroke();
            fill(node.hue, node.saturation, node.brightness, 0.1 - i * 0.02);
            ellipse(node.x, node.y, node.radius * (2 + i));
          }
          
          // Draw main node circles
          noStroke();
          fill(node.hue, node.saturation, node.brightness, 0.9);
          ellipse(node.x, node.y, node.radius * 2);
          
          // Draw inner highlight
          fill(node.hue, node.saturation - 20, node.brightness + 10, 0.5);
          ellipse(node.x - node.radius * 0.3, node.y - node.radius * 0.3, node.radius);
        }
        
        // Draw hover information
        if (this.hoverNode) {
          this.drawNodeInfo(this.hoverNode);
        }
        
        // Draw SMU logo
        this.drawSMULogo();
      }
      
      drawMustangElements() {
        for (let element of this.mustangElements) {
          push();
          translate(element.x, element.y);
          rotate(element.angle + PI/2);
          
          // Draw a stylized mustang silhouette
          noStroke();
          fill(0, 0, 40, 0.2);
          
          // Simple mustang shape
          beginShape();
          vertex(-element.size/3, -element.size/2);    // Head top
          vertex(element.size/3, -element.size/4);     // Mane
          vertex(element.size/3, element.size/4);      // Back
          vertex(0, element.size/2);                  // Tail
          vertex(-element.size/4, element.size/4);     // Legs
          vertex(-element.size/3, -element.size/2);    // Back to head
          endShape(CLOSE);
          
          pop();
        }
      }
      
      drawSMULogo() {
        // Draw a simplified SMU logo in the bottom right corner
        const size = 60;
        const x = width - size - 20;
        const y = height - size - 20;
        
        noStroke();
        fill(this.smuRed[0], this.smuRed[1], this.smuRed[2], 0.9);
        
        // Draw a simplified SMU shield
        beginShape();
        vertex(x, y);
        vertex(x + size, y);
        vertex(x + size, y + size * 0.8);
        vertex(x + size/2, y + size);
        vertex(x, y + size * 0.8);
        endShape(CLOSE);
        
        // Text "SMU"
        fill(255);
        textAlign(CENTER, CENTER);
        textSize(size * 0.4);
        textStyle(BOLD);
        text("SMU", x + size/2, y + size * 0.4);
        
        // Text "2026"
        textSize(size * 0.25);
        text("2026", x + size/2, y + size * 0.65);
      }
      
      drawConnections() {
        for (let conn of this.connections) {
          const start = conn.start;
          const end = conn.end;
          
          // Calculate distance and opacity based on it
          const d = dist(start.x, start.y, end.x, end.y);
          const maxDist = 150;
          const opacity = map(min(d, maxDist), 0, maxDist, conn.strength, 0.05);
          
          // Active connections are red, inactive are blue (SMU colors)
          const hue = end.active ? this.smuRed[0] : this.smuBlue[0];
          const sat = end.active ? this.smuRed[1] : this.smuBlue[1];
          const brightness = end.active ? this.smuRed[2] : this.smuBlue[2];
          
          stroke(hue, sat, brightness, opacity);
          strokeWeight(end.active ? 1 : 0.5);
          line(start.x, start.y, end.x, end.y);
        }
      }
      
      drawBackgroundGradient() {
        // Create a subtle radial gradient with SMU-inspired dark blue background
        background(220, 60, 8); // Dark blue
        
        const gradientRadius = max(width, height);
        for (let r = gradientRadius; r > 0; r -= 2) {
          const brightness = map(r, 0, gradientRadius, 4, 12);
          noStroke();
          fill(220, 50, brightness, 0.01);
          ellipse(width/2, height/2, r * 2);
        }
      }
      
      drawNodeInfo(node) {
        const data = node.data;
        const infoX = node.x + node.radius * 2.5;
        const infoY = node.y;
        
        // Draw info panel background with SMU styling
        fill(220, 60, 15, 0.9); // Dark blue background
        stroke(this.smuRed[0], this.smuRed[1], this.smuRed[2]);
        strokeWeight(2);
        rectMode(CORNER);
        rect(infoX - 10, infoY - 10, 220, 150, 10);
        
        // Draw info text
        noStroke();
        textAlign(LEFT, TOP);
        fill(360, 0, 90);
        textSize(16);
        text(`Group Range: ${data.groupRange}`, infoX, infoY);
        
        textSize(14);
        fill(360, 0, 80);
        text(`Total Groups: ${data.avgTotal.toFixed(1)}`, infoX, infoY + 25);
        
        // Use SMU red for active groups
        fill(this.smuRed[0], this.smuRed[1], this.smuRed[2]);
        text(`Active Groups: ${data.avgActive.toFixed(1)}`, infoX, infoY + 50);
        
        // Use SMU blue for inactive groups
        fill(this.smuBlue[0], this.smuBlue[1], this.smuBlue[2]);
        text(`Inactive Groups: ${(data.avgTotal - data.avgActive).toFixed(1)}`, infoX, infoY + 75);
        
        fill(360, 0, 90);
        text(`Activation Rate: ${data.activeRatio.toFixed(1)}%`, infoX, infoY + 100);
        
        // Add SMU tagline
        fill(this.smuRed[0], this.smuRed[1], this.smuRed[2], 0.8);
        textStyle(ITALIC);
        textSize(10);
        text("World Changers Shaped Here", infoX, infoY + 130);
        textStyle(NORMAL);
      }
      
      checkHover(x, y) {
        let hoveredNode = null;
        
        // Reset hover state
        for (let node of this.nodes) {
          node.hovering = false;
        }
        
        // Check main nodes
        for (let node of this.nodes) {
          const d = dist(x, y, node.x, node.y);
          if (d < node.radius) {
            hoveredNode = node;
            node.hovering = true;
            break;
          }
        }
        
        this.hoverNode = hoveredNode;
      }
    }
  </script>
</body>
</html>